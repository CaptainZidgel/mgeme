
{{define "content"}}
<script src="https://unpkg.com/vue@3"></script>
<h1>Hi</h1>
<div id="app">
	<div id="statusBox" v-if="serviceStatus.status > 0">
		<p>{{"{{serviceStatus.msg}}"}}
	</div>
	<div id="rupBox" v-if="rupStatus.showPrompt">
		<h3>{{"{{rupPromptMessage()}}"}}</h3>
		<button v-on:click="readyUp(true)" v-if="!rupStatus.selfRupped">Ready</button>
		<p>{{"{{rupTimeLeft}}"}} Seconds Remaining</p>
	</div>
		
	<div id="matchDetails" v-if="matchDetails != null">
		<div v-if="matchDetails.alive">
			<p>You're in a match</p>
			<p>{{"{{matchDetails.p1Id}}"}} vs {{"{{matchDetails.p2Id}}"}}</p>
			<p>connect {{"{{matchDetails.gameServer.ip}}"}}:{{"{{matchDetails.gameServer.port}}"}}; password 2p2j</p>
			<p>You have {{"{{connectTimeLeft}}"}} seconds left to connect!
		</div>
		<div v-else>
			<p>You have failed to appear for your court date. Shame, shame on you.</p>
		</div>
	</div>
	<div v-if="!loggedIn">
		<h3>You're not logged in!</h3>
		<a href="/login?redirect=queue"><img src="https://steamcdn-a.akamaihd.net/steamcommunity/public/images/steamworks_docs/english/sits_small.png"/></a>
	</div>
	<div v-else>
		<div v-if="socket && socket.readyState === socket.OPEN">
			{{/*A quick Go comment for templating: Since Go and Vue both use curly braces, you're going to have to place your vue content in a string inside the Go braces*/}}
			{{"{{arrow}}"}}<button v-if="matchDetails == null" v-on:click="joinLeaveQueue(!this.inQueue)">{{"{{inQueueMessage()}}"}}</button>
			<br>
			<br>
			<button v-on:click="newMatch({X: '1v1'})">Test match (2 real players)</button>
			<button v-on:click="newMatch({X: '1v_'})">Test match (1 real player) </button>
			<br>
			<br>
		</div>
		<div v-else>
			<h1>Waiting to connect to server...</h1>
		</div>
	</div>
	<h2>Queue</h2>
	<ul>
		<li v-for="value in serverQueue">
			{{"{{value.Steamid}}"}} :  {{"{{value.User.Nickname}}"}}
		</li>
	</ul>
</div>
<script>
//const SERVICE_HEALTHY = 0
//const SERVICE_UNHEALTHY = 1
//const SERVICE_INTERRUPTED = 2
const app = Vue.createApp({
	data() {
		return {
			arrow: "--->",
			socket: null, //shoutout https://github.com/NerdCademyDev/golang/blob/main/09_web_sockets/client/src/App.vue
			inQueue: false, //at some point I should implement pinging the server in mounted() to confirm
			serverQueue: [],
			loggedIn: {{.loggedIn}}, //Receive loggedIn variable from Go server
			rupStatus: {
				showPrompt: false,		//show the Ready Up alert to player. if self isn't rupped, show "hi you should ready up"
				selfRupped: false,	//if self is rupped and partner isn't, show "waiting for partner" (if self is rupped and partner is, the alert would go away anyway)
				expireAt: 0,
			},
			rupTimer: null,
			rupTimeLeft: 0,
			connectTimer: null,
			connectTimeLeft: 0,
			matchDetails: null,
			serviceStatus: {
				status: 0,
				code: null,
				msg: null,
			},
			steamid: null, 
			//Steamid is inherited from the gin template. Sessions are held in server and can't be read by clients (good!). 
			//However I want to use it sometimes. However a bad actor could change their client data.
			// So use this variable for some non-important purposes but never send it to the server (the server should use sessions)
		}
	},
	mounted() { //lifecycle hook 
		if (this.loggedIn) {
			this.socket = new WebSocket("ws://{{.wsHost}}:{{.wsPort}}/websock")
			this.steamid = {{.steamid}}
		}
		this.socket.onopen = () => console.log("ws Connection established")
		this.socket.onclose = function(event) {
			if (event.wasClean) {
				console.log(`ws Connection closed, code=${event.code} reason=${event.reason}`);
			} else {
				console.log("ws Connection died");
			}
		}
		this.socket.onerror = (error) => console.log(`ws err: ${error.message}`)
		this.socket.onmessage = (event) => {
			let data = JSON.parse(event.data)
			console.log(`Received ${event.data}, ${data.type}.`, this)

			if (data.type == "AckQueue") { //{type: "AckQueue", queue: {steamids: {queue info}} the queue map will eventually be changed to a list
				let ids = Object.keys(data.queue) //this line should become deprecated before production, i.e. let ids = data.queue
				this.inQueue = data.isInQueue
				this.serverQueue = data.queue
			} else if (data.type == "RupSignal") {
				let show = data.showPrompt
				this.rupStatus.showPrompt = show
				if (show) {
					this.rupStatus.selfRupped = false
					this.rupStatus.expireAt = data.expireAt
					this.updateRupTimeLeft()
					console.log("Beginning RUP timer")
					this.rupTimer = setInterval(() => {
						this.updateRupTimeLeft()
					}, 1000)
				}
			} else if (data.type == "MatchDetails") {
				this.matchDetails = data
				this.matchDetails.alive = true
				this.connectTimeLeft = 180
				this.connectTimer = setInterval(() => {
					this.updateConnectTimeLeft()
				}, 1000)
			} else if (data.type == "MatchCancel") {
				delinq = data.payload.delinquents
				this.matchDetails.alive = false
				if (delinq.includes(this.steamid)) {
					return
				}
			} else if (data.type == "ServerIssue") {
				let code = data.code
				let level = parseInt(code.toString()[0])
				this.serviceStatus = {
					status: level,
					code: code,
					msg: data.msg,
				}
			}
		}
	},
	methods: { //functions we can call
		inQueueMessage() {
			return this.inQueue ? "Unadd" : "Add Up"
		},
		rupPromptMessage() {
			return this.rupStatus.selfRupped ? "Waiting on Partner" : "Are you ready to play?"
		},
		epoch() {
			return Math.floor(Date.now() / 1000)
		},
		updateRupTimeLeft() {
			let now = this.epoch()
			let expire = this.rupStatus.expireAt
			console.log("t:", now, expire)
			if (expire < now) {
				console.log("t: clearing")
				this.rupStatus.showPrompt = false
				clearInterval(this.rupTimer)
			} else {
				this.rupTimeLeft = expire - now
			}
		},
		updateConnectTimeLeft() {
			let now = this.epoch()
			let expire = this.matchDetails.deadline
			if (expire - now <= 0) {
				clearInterval(this.connectTimer)
			} else {
				this.connectTimeLeft = expire - now
			}
		},
		joinLeaveQueue(joining) {
			console.log("Sending QUpdate", joining)
			this.socket.send(JSON.stringify({type: "QueueUpdate", payload: {joining: joining}}))
		},
		newMatch(payload) {
			this.socket.send(JSON.stringify({type: "TestMatch", payload: payload}))
		},
		readyUp(r) {
			this.rupStatus.selfRupped = r
			this.socket.send(JSON.stringify({type: "Ready"}))
		},
	},
	beforeDestroy() {
		clearInterval(this.rupTimer)
	}
})

app.mount("#app")

</script>
<style>
	#rupBox {
		background-color: gray;
		width: 200px;
		height: 200px;
		display: block;
		position: absolute;
	}

	#rupBox button {
		background-color: green;
		width: 90%;
		align-self: center;
	}
	
	#statusBox {
		background-color: red;
		padding: 15px;
	}
</style>
{{end}}
